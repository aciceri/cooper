\documentclass[11pt,letterpaper,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[italian]{babel}
\usepackage{minted}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage[backend=bibtex,style=verbose-trad2]{biblatex}

\bibliography{elaborato} 

\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{io} = [rectangle, rounded corners, minimum width=3cm, minimum
height=1cm,text centered, draw=black]
\tikzstyle{procedure} = [rectangle, minimum width=3cm, minimum height=1cm,text
centered, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{document}

\newcommand{\src}[2]{\inputminted[linenos, mathescape=true, firstline={#1},
  lastline={#2}]{C}{../cooper.c}}
\newcommand{\inline}[1]{\mintinline{C}{#1}}

\title{%
  Algoritmo di eliminazione dei quantificatori di Cooper\\
  \large una semplice implementazione scritta in linguaggio C}
\author{Andrea Ciceri}
\maketitle

\begin{abstract}
  L'algoritmo di Cooper permette di effettuare l'eliminazione dei quantificatori
  universali da formule dell'aritmetica di Presburger. In questo documento
  verr\`a descritto l'algoritmo e verr\`a discussa una semplice implementazione
  in C di una versione ridotta dell'algoritmo atta ad interfacciarsi al
  software di model checking MCMT\autocite{mcmt}.  
\end{abstract}

\section{Aritmetica di Presburger}
Sia $\mathbb{Z}$ l'anello degli interi, sia $\Sigma_{\mathbb{Z}}$ la segnatura
$\{0, +, -, <\}$ e sia $\mathcal{A}_{\mathbb{Z}}$ il modello standard degli
interi.
Definiamo la teoria dell'\textbf{aritmetica di Presburger} come l'insieme
$T_{\mathbb{Z}}=Th(\mathcal{A}_{\mathbb{Z}})=Th(\mathbb{Z}, 0, 1, +, -, <)$ di
tutte le $\Sigma_{\mathbb{Z}}$-formule vere in $\mathcal{A}_{\mathbb{Z}}$.
Tale teoria non ammette l'eliminazione dei quantificatori.

Consideriamo ora la segnatura estesa $\Sigma_{\mathbb{Z}}^*$ ottenuta aggiungendo
a $\Sigma_{\mathbb{Z}}$ un'infinit\`a di predicati unari di divisibilt\`a $D_k$
per ogni $k \ge 2$, dove $D_k(x)$ indica che $x \equiv_k 0$.
Sia $T_{\mathbb{Z}}^*$ l'insieme delle $\Sigma_{\mathbb{Z}}$-formule vere
nell'espansione $\mathcal{A}_{\mathbb{Z}}^\star$ ottenuta da
$\mathcal{A}_{\mathbb{Z}}$.

Nel \date{1930} Moj\.zesz Presburger ha esibito un algoritmo di eliminazione dei
quantificatori\autocite{presburger} per $T_{\mathbb{Z}}^*$ e nel \date{1972} Cooper ha fornito una
versione migliorata basata sull'eliminazione dei quantificatori da formule nella
forma $\exists \,x \,.\, \varphi$, dove $\varphi$ \`e una formula senza
quantificatori arbitraria.


\section{L'algoritmo di Cooper}
Si ha quindi che l'algoritmo ha come ingresso una formula del tipo $\exists
\,x \,.\, \varphi$ e come uscita una una formula equivalente senza il
quantificatore esistenziale. Se si vogliono eliminare pi\`u quantificatori
esistenziali basta reiterare l'algoritmo.

Si osserva come ovviamente ogni formula contenente quantificatori universali
possa essere trasformata in una formula equivalente con soli quantificatori
esistenziali.
Pertanto non si ha una perdita di generalit\'a ad assumere un input in tale
forma.

\subsection{Processo di semplificazione}
In questo passaggio vengono effettuate le seguenti semplificazioni alla formula
in ingresso $\varphi$:
\begin{itemize}
\item Tutti i connettivi logici composti, cio\`e che non sono $\lnot$, $\land$ o
  $\lor$, vengono sostituiti nella loro definizione in termini di $\lnot$,
  $\land$ o $\lor$.
\item I predicati binari $\ge$ e $\le$ vengono sostituiti con le loro
  definizioni (e.g. $s \le t$ diventa $s < t + 1$). 
\item Le diseguaglianze negate della forma $\lnot (s < t)$ vengono sostituite
  con $t < s + 1$.
\item Tutte le equazioni e le disequazioni vengono riscritte in modo da avere
  $0$ nel lato sinistro ($s=t$ e $s<t$ diventano $0=t-s$ e $0<t-s$).
\item Tutti gli argomenti dei predicati vengono sostituiti con la loro forma
  canonica.
\end{itemize}
Dopo aver applicato queste sostituzioni e aver trasformato la $\varphi$ ottenuta
in forma normale negativa possiamo dunque assumere che $\varphi$ sia
congiunzione e disgiunzione dei seguenti tipi di letterali:

$$0=t \qquad \lnot(0=t) \qquad 0<t \qquad D_k(t) \qquad \lnot D_k(t)$$
Diremo che $\varphi$ in tale forma \'e una \textbf{formula ristretta}.

\subsection{Normalizzazione dei coefficienti}
Assumiamo quindi che l'algoritmo riceva in ingresso $\exists \, x \, . \,
\varphi$ con $\varphi$ formula ristretta. Il primo passaggio consiste nel
trasformare $\varphi$ in una formula dove il coefficiente della $x$ \`e sempre
lo stesso. Per fare questo \`e sufficiente calcolare il minimo comune multiplo
$l$ di tutti i coefficienti di $x$ ed effettuare i seguenti passi:
\begin{itemize}
  \item Per le equazioni e le equazioni negate, rispettivamente nella forma
    $0=t$ e $\lnot (0=t)$, si moltiplica $t$  per $l/c$, dove $c$ indica il
    coefficiente della $x$.
  \item Analogamente, per i predicati di divisibilit\`a $D_k(t)$ e i predicati
    di divisibilt\`a negati $\lnot D_k(t)$ si moltiplica sia $t$ che $k$ per
    $l/c$, sempre dove $c$ indica il coefficiente della $x$.
  \item Per le diseguaglianze $0<t$ si moltiplica $t$ per il valore assoluto
    $l/c$, dove ancora un volta $c$ indica il coefficiente della $x$.
  \end{itemize}

Quindi ora tutti i coefficienti della $x$ in $\varphi$ sono $\pm l$, passiamo
ora a considerare la seguente formula equivalente:

$$ \exists \, x . \, (D_l(x) \land \psi)  $$
dove $\psi$ \`e ottenuta da $\varphi$\ sostituendo $l \cdot x$ con $x$.
Dunque la formula $\varphi' = D_l(x) \land \psi$ \`e una formula ristretta dove
i coefficienti della $x$ sono $\pm 1$.

\subsection{Costruzione di $\varphi'_{- \infty}$}
Definiamo una nuova formula $\varphi'_{- \infty}$ ottenuta partendo da
$\varphi'$ e sostituendo tutte le formule atomiche $\alpha$ con $\alpha_{-
  \infty}$ secondo la seguente tabella:

\begin{center}
  \begin{tabular}{ l | c }
    $\alpha$ & $\alpha_{- \infty}$ \\ \hline
    $0=t$ & falso \\
    $0 < t$ con $1 \cdot x$ in $t$ & falso \\
    $0 < t$ con $-1 \cdot x$ in $t$ & vero \\
    ogni altra formula atomica $\alpha$ & $\alpha$ \\
  \end{tabular}
\end{center}

\subsection{Calcolo dei boundary points}
Ad ogni letterale $L[x]$ di $\varphi '$ contenente la $x$ che non \`e un
predicato di divisibilit\`a associamo un intero, detto \textbf{boundary point},
nel seguente modo:

\begin{center}
  \begin{tabular}{ l | c }
    Tipo di letterale & Boundary point \\ \hline
    $0=x+t$ & il valore di $(-t + 1)$ \\
    $\lnot (0 < x+t)$ & il valore di $-t$ \\
    $0 < x + t$ & il valore di $-t$ \\
    $0 < -x + t$ &  niente
  \end{tabular}
\end{center}
Si osserva come nel caso la formula $\varphi$ contenga pi\`u variabili da eliminare
allora i valori nella colonna di destra possano dipendere da altre variabili.
Chiamiamo $B$-set l'insieme di questi boundary points.

\subsection{Eliminazione dei quantificatori}
Quest'ultimo passaggio \`e semplicemente l'applicazione della seguente
equivalenza\autocite{cooper}:

$$ \exists \, x \, . \, \varphi'[x] \longleftrightarrow \bigvee_{j=1}^m \Big(
\varphi'_{- \infty}[j] \lor \bigvee_{b \in B}(\varphi'[b+j]) \Big)$$
dove $\varphi'$ \`e la formula ristretta in cui i coefficienti della $x$ sono
sempre $\pm 1$, $m$ \`e il minimo comune multiplo di tutti i $k$ dei predicati
di divisbilit\`a $D_k(t)$ che appaiono in $\varphi'$ tali che appaia la $x$ in
$t$ e infine $B$ \`e il $B$-set relativo a $\varphi'$.
Considerando quindi il lato destro della precedente equivalenza si ha una
formula priva del quantificatore esistenziale e si ha dunque ottenuto ci\`o che
si voleva.

\section{Implementazione}
Il software \`e stato scritto nel linguaggio C rispettando lo standard
C99\autocite{c99}, in questo capitolo verrà effettuata una discussione riguardo
l'implementazione.

\subsection{Struttura e design}

\begin{center}
\begin{tikzpicture}[node distance=2cm]
  \node (input) [io] {Formula in ingresso};
  \node (parse) [procedure, below of=input] {\inline{parse();}};
  \node (normalize) [procedure, below of=parse] {\inline{normalize();}};
  \node (minInf) [procedure, below of=normalize, xshift=-3cm] {\inline{minInf();}};
  \node (boundaryPoints) [procedure, below of=normalize, xshift=3cm] {\inline{boundaryPoints();}};
  \node (newFormula) [procedure, below of=minInf, xshift=3cm] {\inline{newFormula();}};
  \node (output) [io, below of=newFormula] {Formula equivalente};
  \draw [arrow] (input) -- (parse);
  \draw [arrow] (parse) -- (normalize);
  \draw [arrow] (normalize) -- (minInf);
  \draw [arrow] (normalize) -- (boundaryPoints);
  \draw [arrow] (minInf) -- (newFormula);
  \draw [arrow] (boundaryPoints) -- (newFormula);
  \draw [arrow] (newFormula) -- (output);
\end{tikzpicture}
\end{center}

L'algoritmo \`e stato suddiviso in svariate procedure, implementate come singole
funzioni in C, è possibile eseguire l'intero algoritmo chiamando la funzione
\inline{char* cooper(char* wff, char* var)}, dove \inline{wff} è una formula ben
formata (well-formed formula) nel linguaggio SMT-LIB\autocite{smtlib} e
\inline{var} è la variabile da eliminare.
Naturalmente la funzione restituisce la formula equivalente priva della
variabile.
Si rimanda a più tardi la discussione della forma esatta che deve avere la
formula in ingresso.

La funzione \inline{cooper} effettua quindi a sua volta delle chiamate a varie
funzioni, si è cercato per quanto possibile di mantenere la suddivisione di
queste sotto-procedure fedele alla descrizione dell'algoritmo svolta
precedentemente.


Prima di spiegare il comportamento delle singole funzioni occorre accennare che
l'oggetto principale manipolato dal programma è l'albero sintattico stesso della
formula. Per ottenere ciò si è creato un tipo strutturato chiamato
\inline{t_syntaxTree} ad hoc. Si rimanda a più tardi una discussione
dettagliata del tipo in questione.

La funzione che ha quindi il compito di effettuare il parsing è
\inline{t_syntaxTree* parse(char* wff)}, ed è questo appena introdotto il tipo
che ritorna.

Il passo successivo al parsing è la normalizzazione della formula, cioè la generazione
della formula $\varphi' = D_l(x) \land \psi$, dove i coefficienti della variabile
da eliminare sono diventati $1$. La segnatura di tale funzione è \inline{void
  normalize(t_syntaxTree* tree, char* var)}.

Le funzioni \inline{t_syntaxTree* minInf(t_syntaxTree* tree, char* var)} e \newline
\inline{t_syntaxTree* boundaryPoints(t_syntaxTree* tree, char* var)}, come è
facile evincere, generano rispettivamente $\varphi' _{- \infty}$ e l'insieme dei
boundary points.

Infine \inline{t_syntaxTree* newFormula(t_syntaxTree* tree,
  t_syntaxTree* minf, char* var)} genera la formula equivalente a partire da
$\varphi '_{- \infty}$ e della formula normalizzata. \`E al suo interno che viene
effettuata la chiamata a \inline{boundaryPoints();}.

Esiste inoltre un ulteriore passo opzionale non facente parte dell'algoritmo di
Cooper, la funzione \inline{void simplify(t_syntaxTree* t)}, che può essere
chiamata passando come argomento l'output di \inline{newFormula()}, effettua una
rozza semplificazione della formula. Verrà discusso successivamente in dettaglio
cosa si intende. 

\subsection{Analisi del codice}
Quella che viene presentata qui è un'analisi dettagliata del codice sorgente del
programma riga per riga.

\src{521}{600} %main()

Alla luce di quanto detto precedentemente il funzionamento di \inline{cooper()}
risulta autoesplicativo. \'E quindi arrivato il momento di esporre la segnatura
completa del tipo composto \inline{t_syntaxTree}.

\src{16}{20} %segnatura di t_syntaxTree

Trattasi di un record definito ricorsivivamente avente $3$ campi:

\begin{itemize}
  \item \inline{char nodeName[16]} è una stringa di lunghezza fissata posta
    arbritrariamente a 16 caratteri, è il nome del nodo nell'albero sintattico.
  \item \inline{int nodesLen} è il numero di figli del nodo in questione
  \item \inline{t_syntaxTree** nodes} è un array di puntatori ad altri nodi
\end{itemize}

Si consideri la formula in pseudolinguaggio
$((2 = x) \; \land \; (3y + 4 + 5= 0)) \; \lor \; (x \equiv_{6} 0)$, in
linguaggio SMT-LIB essa corrisponde a \inline{(and (or (= 2 x) (= (+ (* 3 y) 4
  5) 0)) (div x 6))} e la sua rappresentazione tramite il tipo composto appena
definito è chiarificata dal segente diagramma.

\begin{center}
  \begin{tikzpicture}[grow=right,
    level 1/.style={sibling distance=12em},
    level 2/.style={sibling distance=9em},
    level 3/.style={sibling distance=5em},
    every node/.style = {rectangle, rounded corners, minimum width=1cm, minimum height=0.5cm,text
centered, draw=black}]]
    \node {and}
    child { node {or}
      child {node {=}
        child {node {2}}
        child {node {x}}}
      child {node {=}
        child {node {+}
          child {node {*}
            child {node {3}}
            child {node {y}}}
          child {node {4}}
          child {node {5}}}
        child {node {0}}}}
    child { node {div}
      child {node {x}}
      child {node {6}}};
  \end{tikzpicture}
\end{center}

Le foglie dell'albero sono semplicemente nodi con l'attributo \inline{nodesLen}
valente $0$, in tal caso è irrilevante il contenuto del campo \inline{nodes}. Si
approfitta di questo momento per sottolineare l'importanza di una opportuna
funzione di deallocazione di questa struttura.

\src{204}{211} %recFree

La natura ricorsiva del tipo \inline{t_syntaxTree} rende notevolmente semplice
la scrittura di una funzione ricorsiva per la liberazione della memoria, come è
semplice intuire tale funzione effettua una visita in profondità dell'albero
deallocando nodo per nodo.

Si passi ora a considerare due funzioni speculari, la funzione
\inline{t_syntaxTree* parse(char* wff)} che trasforma una stringa nel
corrispettivo albero sintattico e la funzione \inline{char*
  treeToStr(t_syntaxTree* tree)} che realizza l'esatto opposto.

\src{23}{104} %parse

La funzione \inline{parse} si appoggia alla funzione \inline{buildTree}, è in
quest'ultima la funzione, ancora una volta ricorsiva, dove avviene la vera e
propria costruzione dell'albero. Essa prende in ingresso i token che compongono
la stringa in ingresso e restituisce l'albero, la parte di suddivisione in token
viene effettuata (insieme ad altre questioni di gestione della memoria) da
\inline{parse}. Tali funzioni prevedono che la stringa in ingresso rispetti
esattamente la sintassi stabilita, e che inoltre, a causa della scelta arbitraria
di porre $16$ caratteri come lunghezza del campo \inline{nodeName} non siano
presenti token più lunghi.

\src{483}{518} %treeToStr

Si consideri ora la funzione speculare \inline{treeToStr}, anch'essa si
appoggia a sua volta ad un'altra funzione, ovvero \inline{recTreeToStr}, è in
quest'ultima che avviene la trasformazione da albero in stringa, rendendo quindi
\inline{treeToStr} funge solamente da una funzione helper.

Si ritorni ora a considerare i passi principali dell'algoritmo, così come sono
esposti nella funzione \inline{cooper}, dopo quanto detto finora rimane da
considerare l'implementazione effettiva dell'algoritmo.

\src{525}{530} %passi fondamentali di cooper

Ovvero rimangono da discutere le funzioni \inline{normalize}, \inline{minInf} e
\inline{newFormula}. Si adempia subito all'incombenza data dalla funzione
\inline{simplify}, di cui si ricorda fare parte di un passo opzionale.

\src{442}{480}

Tale funzione effettua una visita in ampiezza dell'albero alla ricerca di nodi
\inline{or} o \inline{and} ed effettuando una sostituzione di questi ultimi,
rispettivamente con \inline{true} e \inline{false} nel caso almeno uno degli
operandi di \inline{or} sia \inline{true} o uno degli operandi di \inline{and}
sia \inline{false}. La visita in ampiezza viene troncata nel caso si verifichi
uno di questi casi, in quanto il valore dell'espressione è già determinabile,
risulta chiaro da questo il perchè della visita in ampiezza e non in profondità.
Si faccia notare come questa funzione di semplificazione possa essere
notevolmente migliorata aggiungendo la valutazione delle espressioni, tuttavia
questa non banale aggiunta esula dallo scopo del progetto.
In sostanza questa funzione fornisce un buon compromesso tra i benefici che
porta il poter accorciare le espressioni generate dall'algoritmo e una ulteriore
complessità aggiunta. Si noti infine come ancora una volta occorre prestare
attenzione alla corretta deallocazione della memoria.

\`E giunto infine il momento di analizzare la funzione \inline{normalize}, tale
funzione si appoggia a sua volta alle funzione \inline{getLCM} che a sua volta
richiama \inline{gcd} e \inline{lcm}.

\src{6}{13} %gcd e lcm

Come è facile immaginare tali funzioni effettuano semplicemente il calcolo del
massimo comun divisore e del minimo comune multiplo. Il primo viene svolto
efficacemente dall'algoritmo di Euclide\autocite{euclid} mentre il secondo
è dato banalmente dalla seguente.

$$lcm(a, b) = \frac{a b}{GCD(a, b)}$$

La funzione \inline{getLCM} prende in ingresso l'albero sintattico e una
variabile e restituisce il minimo comune multiplo di tutti i coefficienti di
tale variabile presenti nella formula.

\src{107}{121} %getLCM

\inline{getLCM} visita ogni nodo dell'albero alla ricerca dei coefficienti della
variabile \inline{var}, ovvero cerca nodi della forma \inline{(* c var)} dove
appunto \inline{var} è la variabile da eliminare mentre \inline{c} è il
coefficiente. \'E importante sottolineare come i nodi debbano avere il
coefficiente in \inline{.nodes[0]} e la variabile in \inline{.nodes[1]}, cioè
nodi della forma \inline{(* var c)} non vengono correttatamente gestiti.
Tale compromesso porta sicuramente ad una perdita di generalità che in questo
caso particolare potrebbe anche essere evitata, ma lo stesso non si potrà dire
in seguito, pertanto verrà assunto un tale input.

Risulta quindi ora utile discutere quale sia la forma esatta dell'input gestito
dal programma, molte assunzioni che portano a perdita di generalità sono state
fatte, la maggior parte delle quali non evitabili a meno di dover scrivere molte
funzioni ausiliarie di semplificazione. Si è scelta tale strada principalmente
per due motivi:

\begin{itemize}
  \item Già allo stato attuale il programma ha presentato molte difficoltà di
    natura tecnica non inerenti all'implementazione dell'algoritmo. Considerare
    una gamma più ampia di input avrebbe aggiunto una notevole complessità
    derivante dall'utilizzo del C senza nessuna libreria di supporto.
  \item L'obiettivo finale di questo progetto è quello di aggiungere una
    funzionalità al software MCMT\autocite{mcmt}, scrivere una libreria di
    supporto per poter gestire più input avrebbe comportato la riscrittura di
    molto codice già presente in MCMT. Allo stesso tempo interfacciarsi al
    software preesistente avrebbe reso vincolato troppo il progetto, si è
    preferito un approccio intermedio in modo da poter comunque rendere questo
    software il più stand-alone possibile.
\end{itemize}

Si passi dunque ad esaminare la forma di albero più generale possibile in grado
di essere manipolata dal programma; il nodo principale deve essere un
\inline{and} con almeno $1$ figlio, tutti i figli di questo nodo devono essere
obbligatoriamente \inline{=}, \inline{>} o \inline{div}.
Sia \inline{=}, \inline{>} che \inline{div} devono avere esattamente $2$ figli,
il primo (cioè \inline{.nodes[0]}) deve essere un polinomio lineare mentre il
secondo (cioè \inline{.nodes[1]}) deve essere una costante. Il polinomio lineare
deve sempre essere della forma \inline{(+ (* c1 x1) (* c2 x2) ... (* c3
  x3))}, dove come prima, il primo figlio di \inline{*} è una costante e il
secondo è una variabile. La sintassi è questa anche nel caso una delle
costanti sia uguale a $1$.

Non è difficile convincersi che ogni albero può essere trasformato, con mere
manipolazioni simboliche, in un albero di questa forma. Per rendere più chiaro
quanto detto si consideri ad esempio la seguente formula:

$$ \exists \; x \; . \; (2x + y = 3) \land (z < y) \land (x \equiv_{2} 0) $$

Tale formula trasformata in albero risulta equivalente alla seguente, si osservi
come sono stati esplicitati anche i coefficienti $\pm 1$ e come non siano
presenti costanti tra i figli del nodo \inline{+}.

\begin{minted}{c}
  (and (= (+ (* 2 x) (* 3 y)) 3)
       (> (+ (* 1 y) (* -1 z)) 0)
       (div (+ (* 1 x)) 2))
\end{minted}

Ed ecco il listato relativo alla funzione \inline{normalize} nella
sua interezza, si osservi come esso prenda in ingresso l'albero sintattico della
formula e la variabile da eliminare ma ritorni effettivamente \inline{void},
ovvero si osservi come modifichi l'albero senza costruirne uno nuovo. Si faccia
anche caso a come tale funzione sia fortemente vincolata alla rigida struttura
sintattica che è stata supposta. Tale funzione oltre a normalizzare la formula
(tutti i coefficienti della variabile da eliminare diventano $1$) agginuge anche
un opportuno predicato di divisibilità come specificato nell'algoritmo.

\src{124}{201} %normalize

La funzione \inline{minInf}, come suggerisce il nome, riceve in ingresso la
formula normalizzta $\varphi'$ e restituisce $\varphi'_{- \infty}$. A differenza
della funzione precedente essa restituisce effettivamente il nuovo albero.

\src{233}{272} %minInf

Prima di passare alla discussione della funzione \inline{newFormula}, che
effetivamente restituisce la formula equivalente senza variabile, è bene
discutere di alcune altre funzioni a cui essa si appoggia, cioè \inline{calcm} e
\inline{boundaryPoints}.
La funzione \inline{int calcm(t_syntaxTree* tree, char* var)} prende in ingresso
l'albero della formula $\varphi'$ e la variabile da eliminare e restituisce il
minimo comune multiplo di tutti i coefficienti della $x$ che appaiono nella
formula, cioè calcola $m$ dell'equivalenza di cui si è giò discusso.

$$ \exists \, x \, . \, \varphi'[x] \longleftrightarrow \bigvee_{j=1}^m \Big(
\varphi'_{- \infty}[j] \lor \bigvee_{b \in B}(\varphi'[b+j]) \Big)$$

\src{287}{308} %calcm

La funzione \inline{t_syntaxTree* boundaryPoints(t_syntaxTree* tree, char* var)}
riceve ancora in ingresso l'albero sintattico della formula $\varphi'_{- \infty}$
e restituisce il $B$-set $B$ della formula. Per semplicità di rappresentazione
si è scelto di usare ancora come tipo per l'output sempre
\inline{t_syntaxTree}, dove però l'albero avrà come \inline{.nodeName} la
stringa arbitraria \inline{"bPoints"}, tale scelta non ha nessun impatto e
facilita semplicemente il debugging.
  
\src{311}{394} %boundaryPoints

Si discuta ora la funzione che restituisce la formula equivalente che poi
\inline{cooper} ritorna, tale funzione è \inline{t_syntaxTree*
  newFormula(t_syntaxTree* tree, t_syntaxTree* minf, char* var)}, essa non è
altro che l'applicazione dell'equivalenza già esposta più volte. Prende in
ingresso le forumule $\varphi'$ e $\varphi'_{-\infty}$ e la variabile da
eliminare, è al suo interno che vengono effettuate le chiamate a
\inline{boundaryPoints} e \inline{calcm}.

\src{397}{439} %newFormula

La funzione \inline{newFormula} non fa altro che invocare \inline{calcm} e
\inline{boundaryPoints} e generare l'albero della nuova formula equivalente,
albero che poi ritorna. Eliminate le varie questioni di gestione della memoria
quello che rimane è semplicemente un ciclo \inline{for}. La funzione in realtà
fa anche uso di un'ulteriore funzione di valutazione, ovvero una funzione che
prende ingresso un albero, una variabile e un valore e va a sostituire il valore
alla variabile.

Trattasi ovviamente della funzione \inline{void eval(t_syntaxTree* tree, char*
  var, t_syntaxTree* val)}, si osservi anche qui come ovviamente tale funzione
potrebbe essere resa più sofisticata aggiungendo una effettiva valutazione delle
operazioni aritmetiche o logiche, ma come prima anche questo avrebbe aggiunto
una ulteriore complessità al progetto, pertanto si è scelto di non proseguire in
questa strada.


\src{275}{284}

\section{Utilizzo}

In questa sezione verranno forniti alcuni semplici esempi di utilizzo,
innanzitutto si sottolinea come l'implementazione dell'algoritmo termini con la
funzione \inline{cooper}, tutto quello che sta per essere esposto è al solo
scopo di fornire una interfaccia che permetta di verificare il corretto
funzionamento dell'algoritmo.

Si consideri il seguente programma di esempio contenuto in \inline{test.c}:

\inputminted[linenos, mathescape=true]{C}{../test.c}

Si consideri ora il seguente \inline{makefile}:

\inputminted[linenos]{makefile}{../makefile}

\subsection{Script ausiliari}

\subsection{Esempi pratici}



\newpage
\tableofcontents

\printbibliography


\end{document}


%%% TeX-command-extra-options: "-shell-escape"
