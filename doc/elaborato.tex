\documentclass[11pt,letterpaper,twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[italian]{babel}
\usepackage{minted}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{pythontex}
\usepackage[backend=bibtex,style=verbose-trad2]{biblatex}
\usepackage{enumitem}
\usepackage{amssymb}

\newtheorem{lemma}{Lemma}


\bibliography{elaborato} 

\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{io} = [rectangle, rounded corners, minimum width=3cm, minimum
height=1cm,text centered, draw=black]
\tikzstyle{procedure} = [rectangle, minimum width=3cm, minimum height=1cm,text
centered, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{document}

\newcommand{\src}[2]{\inputminted[linenos, mathescape=true, firstline={#1},
  lastline={#2}]{C}{../cooper.c}}
\newcommand{\inline}[1]{\mintinline{C}{#1}}

\begin{pythontexcustomcode}{py}
def lines(f_name):
    with open("../cooper.c", "r") as source_file:
        lines = source_file.readlines()
        found = False
        for i, line in enumerate(lines):
            if not found and f_name in line:
                starting_line = i + 1
                found = True
                brackets = 0
            if found:
                brackets += line.count("{")
                brackets -= line.count("}")
                if brackets == 0:
                    ending_line = i + 1
                    break

        if found:
            return "\src{{{%d}}}{{{%d}}}" % (starting_line, ending_line)
        else:
            return "inline{%s}" % f_name      
\end{pythontexcustomcode}

\newcommand{\srcf}[1]{\pyc{print(lines("#1"))}}

\title{%
  Algoritmo di eliminazione dei quantificatori di Cooper\\
  \large una semplice implementazione scritta in linguaggio C}
\author{Andrea Ciceri}
\maketitle

\begin{abstract} L'algoritmo di Cooper permette di effettuare l'eliminazione dei
quantificatori universali da formule dell'aritmetica di Presburger. In questo
documento verrà descritto l'algoritmo e verrà discussa una semplice
implementazione in C di una versione ridotta dell'algoritmo atta ad
interfacciarsi al software di model checking MCMT\autocite{mcmt}.
\end{abstract}

\section{Aritmetica di Presburger} Sia $\mathbb{Z}$ l'anello degli interi, sia
$\Sigma_{\mathbb{Z}}$ la segnatura $\{0, +, -, <\}$ e sia
$\mathcal{A}_{\mathbb{Z}}$ il modello standard degli interi.  Definiamo la
teoria dell'\textbf{aritmetica di Presburger} come l'insieme
$T_{\mathbb{Z}}=Th(\mathcal{A}_{\mathbb{Z}})=Th(\mathbb{Z}, 0, 1, +, -, <)$ di
tutte le $\Sigma_{\mathbb{Z}}$-formule vere in $\mathcal{A}_{\mathbb{Z}}$.  Tale
teoria non ammette l'eliminazione dei quantificatori.

Consideriamo ora la segnatura estesa $\Sigma_{\mathbb{Z}}^*$ ottenuta
aggiungendo a $\Sigma_{\mathbb{Z}}$ un'infinità di predicati unari di
divisibiltà $D_k$ per ogni $k \ge 2$, dove $D_k(x)$ indica che $x \equiv_k 0$.
Sia $T_{\mathbb{Z}}^*$ l'insieme delle $\Sigma_{\mathbb{Z}}$-formule vere
nell'espansione $\mathcal{A}_{\mathbb{Z}}^*$ ottenuta da
$\mathcal{A}_{\mathbb{Z}}$.

Nel \date{1930} Moj\.zesz Presburger ha esibito un algoritmo di eliminazione dei
quantificatori\autocite{presburger} per $T_{\mathbb{Z}}^*$ e nel \date{1972}
Cooper ha fornito una versione migliorata basata sull'eliminazione dei
quantificatori da formule nella forma $\exists \,x \,.\, \varphi$, dove
$\varphi$ è una formula senza quantificatori arbitraria.

\section{L'algoritmo di Cooper} Si ha quindi che l'algoritmo ha in ingresso una
formula del tipo $\exists \,x \,.\, \varphi$ e in uscita una una formula
equivalente senza il quantificatore esistenziale. Se si vogliono eliminare pi\`u
quantificatori esistenziali basta reiterare l'algoritmo.

Si osserva come ovviamente ogni formula contenente quantificatori universali
possa essere trasformata in una formula equivalente con soli quantificatori
esistenziali.  Pertanto non si ha una perdita di generalità ad assumere un input
in tale forma.

\subsection{Processo di semplificazione} In questo passaggio vengono effettuate
le seguenti semplificazioni alla formula in ingresso $\varphi$:
\begin{itemize}
\item Tutti i connettivi logici composti, cioè che non sono $\lnot$, $\land$ o
$\lor$, vengono sostituiti nella loro definizione in termini di $\lnot$, $\land$
o $\lor$.
\item I predicati binari $\ge$ e $\le$ vengono sostituiti con le loro
definizioni (e.g. $s \le t$ diventa $s < t + 1$).
\item Le diseguaglianze negate della forma $\lnot (s < t)$ vengono sostituite
con $t < s + 1$.
\item Tutte le equazioni e le disequazioni vengono riscritte in modo da avere
$0$ nel lato sinistro ($s=t$ e $s<t$ diventano $0=t-s$ e $0<t-s$).
\item Tutti gli argomenti dei predicati vengono sostituiti con la loro forma
canonica.
\end{itemize} Dopo aver applicato queste sostituzioni e aver trasformato la
$\varphi$ ottenuta in forma normale negativa possiamo dunque assumere che
$\varphi$ sia congiunzione e disgiunzione dei seguenti tipi di letterali:

$$0=t \qquad \lnot(0=t) \qquad 0<t \qquad D_k(t) \qquad \lnot D_k(t)$$
Diremo che $\varphi$ in tale forma è una \textbf{formula ristretta}.

\subsection{Normalizzazione dei coefficienti} Assumiamo quindi che l'algoritmo
riceva in ingresso $\exists \, x \, . \, \varphi$ con $\varphi$ formula
ristretta. Il primo passaggio consiste nel trasformare $\varphi$ in una formula
dove il coefficiente della $x$ è sempre lo stesso. Per fare questo è sufficiente
calcolare il minimo comune multiplo $l$ di tutti i coefficienti di $x$ ed
effettuare i seguenti passi:

\begin{itemize}
  \item Per le equazioni e le equazioni negate, rispettivamente nella forma
$0=t$ e $\lnot (0=t)$, si moltiplica $t$ per $l/c$, dove $c$ indica il
coefficiente della $x$.
  \item Analogamente, per i predicati di divisibilit\`a $D_k(t)$ e i predicati
di divisibilt\`a negati $\lnot D_k(t)$ si moltiplica sia $t$ che $k$ per $l/c$,
sempre dove $c$ indica il coefficiente della $x$.
  \item Per le diseguaglianze $0<t$ si moltiplica $t$ per il valore assoluto
$l/c$, dove ancora un volta $c$ indica il coefficiente della $x$.
\end{itemize}

Quindi ora tutti i coefficienti della $x$ in $\varphi$ sono $\pm l$, passiamo
ora a considerare la seguente formula equivalente:

$$ \exists \, x . \, (D_l(x) \land \psi)  $$
2dove $\psi$ è ottenuta da $\varphi$\ sostituendo $l \cdot x$ con $x$.  Dunque la
formula $\varphi' = D_l(x) \land \psi$ è una formula ristretta dove i
coefficienti della $x$ sono $\pm 1$.

\subsection{Costruzione di $\varphi'_{- \infty}$} Definiamo una nuova formula
$\varphi'_{- \infty}$ ottenuta partendo da $\varphi'$ e sostituendo tutte le
formule atomiche $\alpha$ con $\alpha_{- \infty}$ secondo la seguente tabella:

\begin{center}
  \begin{tabular}{ l | c }
    $\alpha$ & $\alpha_{- \infty}$ \\ \hline
    $0=t$ & falso \\
    $0 < t$ con $1 \cdot x$ in $t$ & falso \\
    $0 < t$ con $-1 \cdot x$ in $t$ & vero \\
    ogni altra formula atomica $\alpha$ & $\alpha$ \\
  \end{tabular}
\end{center}

\subsection{Calcolo dei boundary points} Ad ogni letterale $L[x]$ di $\varphi '$
contenente la $x$ che non è un predicato di divisibilit\`a associamo un intero,
detto \textbf{boundary point}, nel seguente modo:

\begin{center}
  \begin{tabular}{ l | c }
    Tipo di letterale & Boundary point \\ \hline
    $0=x+t$ & il valore di $-(t + 1)$ \\
    $\lnot (0 < x+t)$ & il valore di $-t$ \\
    $0 < x + t$ & il valore di $-t$ \\
    $0 < -x + t$ &  niente
  \end{tabular}
\end{center}

Si osserva come nel caso la formula $\varphi$ contenga più variabili da
eliminare allora i valori nella colonna di destra possano dipendere da altre
variabili.  Chiamiamo $B$-set l'insieme di questi boundary points.

\subsection{Eliminazione dei quantificatori} Quest'ultimo passaggio è
semplicemente l'applicazione della seguente equivalenza\autocite{cooper}:

$$ \exists \, x \, . \, \varphi'[x] \longleftrightarrow \bigvee_{j=1}^m \Big(
\varphi'_{- \infty}[j] \lor \bigvee_{b \in B}(\varphi'[b+j]) \Big)$$ dove
$\varphi'$ è la formula ristretta in cui i coefficienti della $x$ sono sempre
$\pm 1$, $m$ è il minimo comune multiplo di tutti i $k$ dei predicati di
divisbilit\`a $D_k(t)$ che appaiono in $\varphi'$ tali che appaia la $x$ in $t$
e infine $B$ \`e il $B$-set relativo a $\varphi'$.  Considerando quindi il lato
destro della precedente equivalenza si ha una formula priva del quantificatore
esistenziale e si ha dunque ottenuto ciò che si voleva.

\newpage

\section{Complessità computazionale}
In questa sezione verrà formalizzata in modo rigoroso una versione equivalente
dell'algoritmo di Cooper, la quale permetterà di ottenere una stima superiore
della complessità.
Si vedrà infatti che, in un senso che verrà chiarito successivamente, se $n$ è
la dimensione della formula in ingresso, allora la formula equivalente senza
variabili non potrà avere dimensione maggiore di $2^{2^{2^{pn}}}$, per qualche
costante $p$ > 1. Questo fornisce un bound superiore alla complessità temporale.

Una ulteriore osservazione non rigorosa è la seguente; Fischer e Rabin
\autocite{fischer-rabin} hanno trovato un bound inferiore per la complessità di
una versione non deterministica dell'algoritmo, e tale bound risulta avere un
esponenziale in meno. Dunque, siccome algoritmi deterministici che emulano
algoritmi non deterministici non possono che introdurre un esponenziale nella
complessità, risulta auspicabile che il bound superiore trovato non sia
migliorabile.


\subsection{Formalizzazione dell'aritmetica di Presburger}
Si definiscano i simboli del'aritmetica di Presburger:
$$ \mathscr{L} = \{(, ), \land, \lor, \exists, \forall, =, <, +, -, 0, 1, x, y,
z, \dots \}$$
I simboli $x, y, z, \dots$ sono chiamati variabili, essi possono ammettere un
pedice. Una espressione è una successione finita di simboli, si chiami quindi
$\mathscr{L}^{+}$ il linguaggio delle espressioni nell'aritmetica di Presburger.
Un termine è definito nel modo seguente:

\begin{itemize}
  \item Le variabili e i simboli $0$ e $1$ sono termini.
  \item Se $t_1$ e $t_2$ sono termini, lo sono anche $(t_1 + t_2)$ e $-t$.
  \item Questi sono gli unici termini.
\end{itemize}

Una formula atomica è una espressione del tipo $(t_1 < t_2)$ o $(t_1 = t_2)$,
dove $t_1$ e $t_2$ sono termini.
Una formula è definita come segue:
\begin{itemize}
  \item Un atomo è una formula
  \item Se $A$ e $B$ sono formule e $x$ è una variabile, allora $\exists \, x \,
    A$, $\forall \, x \, B$, $(A \land B)$, $(A \lor B)$ e $\lnot A$ sono ancora formule.
  \item Queste sono le sole formule.
\end{itemize}

Si chiami frase una formula che non ha variabili libere.
La semantica del linguaggio è quella naturale, si osservi solo che, per
convenienza di scrittura, verranno usati anche i numerali ($2, 3, \dots$) e
altri simboli non facente parti del linguaggio. Ciononostante essi potranno
sempre essere sostituiti con una composizione dei simboli appena esposti, dunque
non andranno ad inficiare la validità dell'argomento.

\subsection{L'algoritmo di Cooper come procedura decisionale}
L'algoritmo di Cooper, se iterato su di una frase in $\mathscr{L}$ permette di
eliminare tutti i quantificatori, e quindi di valutare la verità di tale
frase. In tale senso può essere inteso come procedura decisonale.
Vengono quindi mostrati i passaggi effettuati dall'algoritmo in una singola
iterazione.

Conseriamo una formula in ingresso della forma $\exists \, x \, F(x)$, dove $F$
è senza quantificatori. Innanzitutto si osservi che assumere il quantificatore
esistenziale non è limitativo in quanto se fosse presente $\forall \, x$, esso
potrebbe essere semplicemente sostituito con $\lnot \, \exists \, x \, \lnot$.

\begin{enumerate}[label=Step \arabic*.]
\item Si eliminano le negazioni logiche portando i $\lnot$ il più lontano
  possibile dagli atomi (per esempio usando le leggi di De Morgan) e
  successivamente si sostituiscono i letterali che consistono di atomi negati con
  atomi equivalenti non negati. (e.g. sostituire $\lnot (x \leq a)$ con $x > a$)
  A questo punto si sostituiscono tutte le formule che contengono altri simboli
  relazionali che non siano $<$, $\mid$ or $\nmid$ in formule equivalenti
  contenenti solo $<$.
\item Sia $\delta'$ il minimo comune multiplo dei coefficienti della $x$, si
  moltiplicano ambo i lati di tutti gli atomi contenenti $x$ per costanti
  appropriate in modo tutti i coefficienti della $x$ siano $\delta'$.
  Infine si sostutuisce $\exists \, x \, F(\delta' x)$ con $\exists \, x \,
  (F(x) \land \delta' \mid x)$.
  Si ha quindi ottenuto una formula equivalente dove ogni atomo che non contiene
  la $x$ deve essere obbligatoriamente in una delle seguenti forme.
  \begin{enumerate}[label=\Alph*.]
    \item $x < a_i$
    \item $b_i < x$
    \item $\delta_i \mid x + c_i$
    \item $\epsilon_i \nmid x + d_i$
  \end{enumerate}
  Dove $a_i, b_i, c_i$ e $d_i$ sono espressioni senza $x$ e $\delta_i$ e
  $\epsilon_i$ sono interi positivi.
\item Sia $\delta$ il minimo comune multiplo dei $\delta_i$ e dei
  $\epsilon_i$. Sia $F_{- \infty}(x)$ il risultato che si ottiene sostituendo in
  $F(x)$ tutte le occrrenze di atomi nella forma $A$ e $B$ con $true$ e
  $false$ rispettivamente. Analogamente si costruisce $F_{\infty}(x)$, dove però
  gli atomi nella forma $A$ vengono sostituiti con $false$ e quelli nella forma
  $B$ con $true$.
  Se il numero degli atomi di tipo $A$ supera il numero degli atomi di tipo $B$
  si sostituisca $\exists \, x \, F(x)$ con
  $$ F^{-\infty} =  \bigvee_{j=1}^{\delta} F_{- \infty}(j) \lor
  \bigvee_{j=1}^{\delta} \bigvee_{b_i} F(b_i + j)$$
  Altrimenti si sostuisca con
  $$ F^{\infty} =  \bigvee_{j=1}^{\delta} F_{\infty}(-j) \lor
  \bigvee_{j=1}^{\delta} \bigvee_{a_i} F(a_i - j)$$
  A questo punto non resta che effettuare una semplificazione raccogliendo
  termini simili.
\end{enumerate}

\subsection{Analisi e stima della complessità}
Sarà messa in relazione la crescita del numero degli atomi e la grandezza delle
costanti con il numero dei coefficienti distinti che appaiono.
Si cominci mostrando il seguente risultato preliminare.

\begin{lemma}
  Si consideri la formula
  $$Q_m x_m Q_{m-1} x_{m-1} \dots Q_2 x_2 Q_1 x_1 \, F(x_1, x_2,
  \dots, x_m)$$
  dove $Q_i = \exists$ oppure $Q_i = \forall$ e $F$ è una
  formula senza quantificatori. 
  Sia $c_k$ la somma del numero di interi positivi distinti che appaiono negli
  atomi della forma $\delta_i \mid t$ e $\epsilon_i \nmid t$ e del numero dei
  coefficienti distinti delle variabili nella formula $$F_k=Q_m x_m Q_{m-1} x_{m-1}
  \dots Q_{k+1} x_{k+1} \, F'_k(x_{k+1}, \dots, x_m)$$ prodotta dopo la $k$-esima
  iterazione.
  Analogamente sia $s_k$ il massimo dei valori assoluti delle costanti intere,
  compresi i coefficienti della variabili.
  Infine sia $a_k$ il numero totale degli atomi in $F_k$.
  
  Allora valgono le seguenti relazioni:
  $$c_1 \le c^4 \qquad s_1 \le s^{4c} \qquad a_1 \le a^4s^{2c}$$

\end{lemma}
\begin{proof}
  Siano $a', a'', a'''$ il numero degli atomi dopo gli step $1$ e $2$ e $3$,
  assumendo che $a$ sia il numero degli atomi prima dell'esecuzione
  dell'algoritmo.
  Analogamnete si definiscano $c', c'', c'''$ e $s', s'', s'''$. Si ripercorrano
  ora i passi dell'algoritmo, considerando mano a mano delle stime per tali
  valori.
  \begin{enumerate}[label=Step \arabic*.]
  \item L'eliminazione delle negazioni logiche non altera nè $c'$ nè $s'$ nè
    $a'$, l'elminazione dei simboli relazionali che non sono $\mid$, $\nmid$ o
    $<$ potrebbe raddoppiare il numero di atomi e potrebbe incrementare di $1$
    il massimo dei valori assoluti delle costanti che non appaiono come
    coefficienti dell variabili.
    Il numero di atomi con simboli relazionali $\mid$ o $\nmid$ resta al massimo
    $a$, dunque, una volta terminato il primo step dell'algoritmo si è nella
    seguente situazione:
    $$ a' \le 2a \qquad s' \le s + 1 \qquad c' \le c $$
  \item Sostituire $x$ con $\delta' x$ potrebbe modificare il valore di $s'$, il
    caso peggiore si verifica quando un atomo contiene sia il termine $x$ (con
    coefficiente $1$) che il termine $s'$. Il termine costante $s'$ diventa
    $\delta' s'$, dove $\delta'$ è il minimo comune multiplo dei coefficienti
    della $x$. Siccome ci sono al massimo $c$ coefficienti distinti della $x$, e
    ognuno di essi vale al massimo $s$, allora $\delta' \le s^c$.
    Dunque $s'' \le s^cs' \le (s+1)^{c+1}$.
    
    Anche il valore di $c''$ può venire alterato, ci sono al massimo $c-1$
    variabili oltre alla $x$ con coefficienti diversi da ogni coefficiente della
    $x$, inoltre ci sono al massimo $c$ coefficienti $c$ coefficienti distinti
    per la $x$. Dunque, $c'$ può crescere al massimo fino a $c(c-1)+2$, dove
    $+2$ è dovuto da un $+1$ per l'eventuale nuovo coefficiente della $x$ (che
    diventa $1$) e un $+1$ è dovuto dalla costante $\delta'$ in $\delta' \mid
    x$. Infine questo step incrementa di $1$ il numero di atomi, riassumendo si
    ha dunque il seguente bilancio.
    $$ a'' \le 2a + 1 \qquad s'' \le (s+1)^{c+1} \qquad c'' \le c^2$$

  \item Si consideri prima $a'''$, il numero degli atomi in
    $\bigvee_{j=1}^\delta F_{-\infty}(j)$ è al massimo $\delta (a+1)$ siccome
    tutti gli atomi con il simbolo relazionale $<$ sono sostituiti da $true$ o
    $false$ e siccome ci sono al massimo $a+1$ atomi della forma $\delta_i \mid
    x + d_i$ o $\epsilon_i \nmid x + e_i$. A questo punto, grazie agli step $1$
    e $2$, il numero di termini $b_i$ è al massimo $a$, inoltre ci sono al
    massimo $2a + 1$ atomi in $F(b_i + j)$. Quindi il numero di atomi in
    $\bigvee_{j=1}^\delta \bigvee_{b_i} F(b_i + j)$ è dominato superiormente da
    $\delta a (2a + 1)$ e il numero di atomi $a'''$ in $F^{-\infty}$ è al
    massimo $\delta (2a^2 +2a +1) \le \delta a^4$, per $a > 1$.

    Occorre trovare ora bound superiore per $\delta$, ogni costante $\delta_i$ o
    $\epsilon_i$ che appare in atomi della forma $\delta_i \mid x + d_i$ o
    $\epsilon_i \nmid x + e_i$ è il prodotto di due interi $\alpha$ e $\beta$,
    dove $\alpha \le s$ e $\beta \mid \delta'$, ciò segue dal passo $2$.
    Ci sono al massimo $c$ valori di $\alpha$ distinti, quindi il minimo comune
    multiplo $\delta$ di tutti i $\delta_i$ e $\epsilon_i$ è al massimo
    $s^c\delta'$. Dunque $\delta \le s^{2c}$ e $a''' \le a^4s^{2c}$.

    La semplificazione dovuta al raccoglimento dei termini simili potrebbe
    alterare sia $s'''$ che $c'''$, la costante più grande potrebbe diventare
    $2s'' + 2^{2c} \le 2(s+1)^{c+1}+s^{2c} \le 3(s+1)^{2c}$.
    Un argomento simile a quello dato al passo $2$ di questa dimostrazione
    fornisce una stima superiore per $c'''$, ovvero $c''' \le c^4$. Riassumendo:
    $$ a''' \le a^4s^{2c} \qquad s''' \le 3(s + 1)^{2c} \qquad c''' \le c^4 $$
    Tuttavia per i nostri scopi saranno sufficienti le seguenti:
    $$ a_1 \le a^4s^{2c} \qquad s_1 \le s^{4c} \qquad c_1 \le c^4 $$
    per $s, c > 2$
  \end{enumerate}
\end{proof}

\begin{lemma}
  Se $s, c > 2$, allora
  $$ c_k \le c^{4^k} \qquad s_k \le s^{(4c)^{4^k}} \qquad a_k \le a^{4^k}s^{(4c)^{4^k}}$$
\end{lemma}
\begin{proof}
  Per induzione sul lemma precedente.
\end{proof}

Si supponga dunque ora che sia data una frase di lunghezza $n$ la quale codifica
$$Q_m x_m Q_{m-1} x_{m-1} \dots Q_2 x_2 Q_1 x_1 \, F(x_1, x_2, \dots, x_m)$$
Si desidera trovare un bound superiore allo spazio richiesto dalla formula senza
quantificatori $F_m$. Si può assumere che $m \le n, c \le n, a \le n, s \le n$,
per ogni $k$ lo spazio richiesto per immagazzinare $F_k$ è stimato dall'alto dal
prodotto del numero degli atomi $a_k$ in $F_k$, il massimo numero $m+1$ di
costanti per atomo, la massima quantità di spazio $s_k$ richiesta per
immagazzinare ogni costante e una qualche costante $q$. Si osservi che il
fattore $q$ è dovuto ai vari operatori logici e aritmetici.
Dunque lo spazio per immagazzinare $F_k$ è stimato superiormente da
$$ q \cdot n^{4^n} \cdot n^{(4n)^{4^n}} \cdot (n+1) \cdot n^{(4n)^{4^n}} \le
2^{2^{2^{pn}}}$$
per una qualche costante $p > 1$
Si affermi che il bound superiore della complessità temporale dell'algoritmo è
dominato dal quadrato del tempo richiesto per generare la $F_k$ più
lunga. Dunque il bound spaziale appena ottenuto è in realtà anche un bound
temporale.


\newpage

\section{Implementazione} Il software \`e stato scritto nel linguaggio C
rispettando lo standard C99\autocite{c99}, in questo capitolo verrà effettuata
una discussione riguardo l'implementazione.

\subsection{Struttura e design}

\begin{center}
\begin{tikzpicture}[node distance=2cm]
  \node (input) [io] {Formula in ingresso};
  \node (parse) [procedure, below of=input] {\inline{parse();}};
  \node (normalize) [procedure, below of=parse] {\inline{normalize();}};
  \node (minInf) [procedure, below of=normalize, xshift=-3cm] {\inline{minInf();}};
  \node (boundaryPoints) [procedure, below of=normalize, xshift=3cm] {\inline{boundaryPoints();}};
  \node (newFormula) [procedure, below of=minInf, xshift=3cm] {\inline{newFormula();}};
  \node (output) [io, below of=newFormula] {Formula equivalente};
  \draw [arrow] (input) -- (parse);
  \draw [arrow] (parse) -- (normalize);
  \draw [arrow] (normalize) -- (minInf);
  \draw [arrow] (normalize) -- (boundaryPoints);
  \draw [arrow] (minInf) -- (newFormula);
  \draw [arrow] (boundaryPoints) -- (newFormula);
  \draw [arrow] (newFormula) -- (output);
\end{tikzpicture}
\end{center}

L'algoritmo \`e stato suddiviso in svariate procedure, implementate come singole
funzioni in C, è possibile eseguire l'intero algoritmo chiamando la funzione
\inline{char* cooper(char* wff, char* var)}, dove \inline{wff} è una formula ben
formata (well-formed formula) nel linguaggio SMT-LIB\autocite{smtlib} e
\inline{var} è la variabile da eliminare.  Naturalmente la funzione restituisce
la formula equivalente priva della variabile.  Si rimanda a più tardi la
discussione della forma esatta che deve avere la formula in ingresso.

La funzione \inline{cooper} effettua quindi a sua volta delle chiamate a varie
funzioni, si è cercato per quanto possibile di mantenere la suddivisione di
queste sotto-procedure fedele alla descrizione dell'algoritmo svolta
precedentemente.

Prima di spiegare il comportamento delle singole funzioni occorre accennare che
l'oggetto principale manipolato dal programma è l'albero sintattico stesso della
formula. Per ottenere ciò si è creato un tipo strutturato chiamato
\inline{t_syntaxTree} ad hoc. Si rimanda a più tardi una discussione dettagliata
del tipo in questione.

La funzione che ha quindi il compito di effettuare il parsing è
\inline{t_syntaxTree* parse(char* wff)}, ed è questo appena introdotto il tipo
che ritorna.

Il passo successivo al parsing è la normalizzazione della formula, cioè la
generazione della formula $\varphi' = D_l(x) \land \psi$, dove i coefficienti
della variabile da eliminare sono diventati $1$. La segnatura di tale funzione è
\inline{void normalize(t_syntaxTree* tree, char* var)}.

Le funzioni \inline{t_syntaxTree* minInf(t_syntaxTree* tree, char* var)} e
\newline \inline{t_syntaxTree* boundaryPoints(t_syntaxTree* tree, char* var)},
come è facile evincere, generano rispettivamente $\varphi' _{- \infty}$ e
l'insieme dei boundary points.

Infine \inline{t_syntaxTree* newFormula(t_syntaxTree* tree, t_syntaxTree* minf,
char* var)} genera la formula equivalente a partire da $\varphi '_{- \infty}$ e
dalla formula normalizzata. \`E al suo interno che viene effettuata la chiamata
a \inline{boundaryPoints}.

Esiste inoltre un ulteriore passo opzionale non facente parte dell'algoritmo di
Cooper, la funzione \inline{void simplify(t_syntaxTree* t)}, che può essere
chiamata passando come argomento l'output di \inline{newFormula()}, effettua una
rozza semplificazione della formula. Verrà discusso successivamente in dettaglio
cosa si intende.

\subsection{Analisi del codice} Quella che viene presentata qui è un'analisi
dettagliata del codice sorgente del programma riga per riga, si è deciso di
seguire il più possibile il flusso di esecuzione del programma, in modo da
evidenziare i passi dell'algoritmo.

\subsubsection{Funzione \inline{cooperToStr}} \srcf{char* cooperToStr}

Alla luce di quanto detto precedentemente il funzionamento di \inline{cooper}
risulta autoesplicativo. \'E quindi arrivato il momento di esporre la segnatura
completa del tipo composto \inline{t_syntaxTree}.

\subsubsection{Segnatura di \inline{t_syntaxTree}} \srcf{typedef struct
t_syntaxTree}

Trattasi di un record definito ricorsivivamente avente $3$ campi:

\begin{itemize}
  \item \inline{char nodeName[16]} è una stringa di lunghezza fissata posta
arbritrariamente a 16 caratteri, è il nome del nodo nell'albero sintattico.
  \item \inline{int nodesLen} è il numero di figli del nodo in questione
  \item \inline{t_syntaxTree** nodes} è un array di puntatori ad altri nodi
\end{itemize}

Si consideri la formula in pseudolinguaggio $((2 = x) \; \land \; (3y + 4 + 5=
0)) \; \lor \; (x \equiv_{6} 0)$, in linguaggio SMT-LIB essa corrisponde a
\inline{(and (or (= 2 x) (= (+ (* 3 y) 4 5) 0)) (div x 6))} e la sua
rappresentazione tramite il tipo composto appena definito è chiarificata dal
segente diagramma.

\begin{center}
  \begin{tikzpicture}[grow=right,
    level 1/.style={sibling distance=12em},
    level 2/.style={sibling distance=9em},
    level 3/.style={sibling distance=5em},
    every node/.style = {rectangle, rounded corners, minimum width=1cm, minimum height=0.5cm,text
centered, draw=black}]]
    \node {and}
    child { node {or}
      child {node {=}
        child {node {2}}
        child {node {x}}}
      child {node {=}
        child {node {+}
          child {node {*}
            child {node {3}}
            child {node {y}}}
          child {node {4}}
          child {node {5}}}
        child {node {0}}}}
    child { node {div}
      child {node {x}}
      child {node {6}}};
  \end{tikzpicture}
\end{center}

Le foglie dell'albero sono semplicemente nodi con l'attributo \inline{nodesLen}
valente $0$, in tal caso è irrilevante il contenuto del campo \inline{nodes}. Si
approfitta di questo momento per sottolineare l'importanza di una opportuna
funzione di deallocazione di questa struttura.

\subsubsection{Funzione \inline{recFree}} \srcf{void recFree}

La natura ricorsiva del tipo \inline{t_syntaxTree} rende notevolmente semplice
la scrittura di una funzione ricorsiva per la liberazione della memoria, come è
semplice intuire tale funzione effettua una visita in profondità dell'albero
deallocando nodo per nodo.

Si passi ora a considerare due funzioni speculari, la funzione
\inline{t_syntaxTree* parse(char* wff)} che trasforma una stringa nel
corrispettivo albero sintattico e la funzione \inline{char*
treeToStr(t_syntaxTree* tree)} che realizza l'esatto opposto.

\subsubsection{Funzione \inline{parse}} \srcf{t_syntaxTree* parse}

La funzione \inline{parse} si appoggia alla funzione \inline{buildTree}, è in
quest'ultima la funzione, ancora una volta ricorsiva, dove avviene la vera e
propria costruzione dell'albero. Essa prende in ingresso i token che compongono
la stringa in ingresso e restituisce l'albero, la parte di suddivisione in token
viene effettuata (insieme ad altre questioni di gestione della memoria) da
\inline{parse}. Tali funzioni prevedono che la stringa in ingresso rispetti
esattamente la sintassi stabilita, e che inoltre, a causa della scelta
arbitraria di porre $16$ caratteri come lunghezza del campo \inline{nodeName}
non siano presenti token più lunghi.

\subsubsection{Funzione \inline{treeToStr}} \srcf{char* treeToStr}

Si consideri ora la funzione speculare \inline{treeToStr}, anch'essa si appoggia
a sua volta ad un'altra funzione, ovvero \inline{recTreeToStr}, è in
quest'ultima che avviene la trasformazione da albero in stringa, rendendo quindi
\inline{treeToStr} funge solamente da una funzione helper.

\srcf{int recTreeToStr}

Si ritorni ora a considerare i passi principali dell'algoritmo, così come sono
esposti nella funzione \inline{cooper}, dopo quanto detto finora rimane da
considerare l'implementazione effettiva dell'algoritmo.

\src{682}{686} %passi fondamentali di cooper

Ovvero rimangono da discutere le funzioni \inline{normalize}, \inline{minInf} e
\inline{newFormula}. Si adempia subito all'incombenza data dalla funzione
\inline{simplify}, di cui si ricorda fare parte di un passo opzionale.

\subsubsection{Funzione \inline{simplify}} \srcf{void simplify}

Tale funzione effettua una visita in ampiezza dell'albero alla ricerca di nodi
\inline{or} o \inline{and} ed effettuando una sostituzione di questi ultimi,
rispettivamente con \inline{true} e \inline{false} nel caso almeno uno degli
operandi di \inline{or} sia \inline{true} o uno degli operandi di \inline{and}
sia \inline{false}. La visita in ampiezza viene troncata nel caso si verifichi
uno di questi casi, in quanto il valore dell'espressione è già determinabile,
risulta chiaro da questo il perchè della visita in ampiezza e non in profondità.
Si faccia notare come questa funzione di semplificazione possa essere
notevolmente migliorata aggiungendo la valutazione delle espressioni, tuttavia
questa non banale aggiunta esula dallo scopo del progetto.  In sostanza questa
funzione fornisce un buon compromesso tra i benefici che porta il poter
accorciare le espressioni generate dall'algoritmo e una ulteriore complessità
aggiunta. Si noti infine come ancora una volta occorre prestare attenzione alla
corretta deallocazione della memoria.

\`E giunto il momento di analizzare la funzione \inline{normalize}, tale
funzione si appoggia a sua volta alle funzione \inline{getLCM} che a sua volta
richiama \inline{gcd} e \inline{lcm}.

\subsubsection{Funzioni \inline{gcd} e \inline{lcm}} \srcf{long int gcd}
\srcf{long int lcm}

Come è facile immaginare tali funzioni effettuano semplicemente il calcolo del
massimo comun divisore e del minimo comune multiplo. Il primo viene svolto
efficacemente dall'algoritmo di Euclide\autocite{euclid} mentre il secondo è
dato banalmente dalla seguente.

$$lcm(a, b) = \frac{a b}{GCD(a, b)}$$

La funzione \inline{getLCM} prende in ingresso l'albero sintattico e una
variabile e restituisce il minimo comune multiplo di tutti i coefficienti di
tale variabile presenti nella formula.

\subsubsection{Funzione \inline{getLCM}} \srcf{int getLCM}

\inline{getLCM} visita ogni nodo dell'albero alla ricerca dei coefficienti della
variabile \inline{var}, ovvero cerca nodi della forma \inline{(* c var)} dove
appunto \inline{var} è la variabile da eliminare mentre \inline{c} è il
coefficiente. \'E importante sottolineare come i nodi debbano avere il
coefficiente in \inline{.nodes[0]} e la variabile in \inline{.nodes[1]}, cioè
nodi della forma \inline{(* var c)} non vengono correttatamente gestiti.  Tale
compromesso porta sicuramente ad una perdita di generalità che in questo caso
particolare potrebbe anche essere evitata, ma lo stesso non si potrà dire in
seguito, pertanto verrà assunto un tale input.

Risulta quindi ora utile discutere quale sia la forma esatta dell'input gestito
dal programma, molte assunzioni che non portano a perdita di generalità sono state
fatte, la maggior parte delle quali non evitabili a meno di dover scrivere molte
funzioni ausiliarie di semplificazione. Si è scelta tale strada principalmente
per due motivi:

\begin{itemize}
  \item Già allo stato attuale il programma ha presentato molte difficoltà di
natura tecnica non inerenti all'implementazione dell'algoritmo. Considerare una
gamma più ampia di input avrebbe aggiunto una notevole complessità derivante
dall'utilizzo del C senza nessuna libreria di supporto.
  \item L'obiettivo finale di questo progetto è quello di aggiungere una
funzionalità al software MCMT\autocite{mcmt}, scrivere una libreria di supporto
per poter gestire più input avrebbe comportato la riscrittura di molto codice
già presente in MCMT. Allo stesso tempo interfacciarsi al software preesistente
avrebbe vincolato troppo il progetto, si è preferito un approccio
intermedio in modo da poter comunque rendere questo software il più stand-alone
possibile.
\end{itemize}

Si passi dunque ad esaminare la forma di albero più generale possibile in grado
di essere manipolata dal programma; il nodo principale deve essere un
\inline{and} con almeno $1$ figlio, tutti i figli di questo nodo devono essere
obbligatoriamente \inline{=}, \inline{>} o \inline{div}.  Sia \inline{=},
\inline{>} che \inline{div} devono avere esattamente $2$ figli, il primo (cioè
\inline{.nodes[0]}) deve essere un polinomio lineare mentre il secondo (cioè
\inline{.nodes[1]}) deve essere una costante. Il polinomio lineare deve sempre
essere della forma \inline{(+ (* c1 x1) (* c2 x2) ... (* c3 x3))}, dove come
prima, il primo figlio di \inline{*} è una costante e il secondo è una
variabile. La sintassi è questa anche nel caso una delle costanti sia uguale a
$1$.

Non è difficile convincersi che ogni albero può essere trasformato, con mere
manipolazioni simboliche, in un albero di questa forma. Per rendere più chiaro
quanto detto si consideri ad esempio la seguente formula:

$$ \exists \; x \; . \; (2x + y = 3) \land (z < y) \land (x \equiv_{2} 0) $$

Tale formula trasformata in albero risulta equivalente alla seguente, si osservi
come sono stati esplicitati anche i coefficienti $\pm 1$ e come non siano
presenti costanti tra i figli del nodo \inline{+}.

\begin{minted}{c}
  (and (= (+ (* 2 x) (* 3 y)) 3)
       (> (+ (* 1 y) (* -1 z)) 0)
       (div (+ (* 1 x)) 2))
\end{minted}

Ed ecco il listato relativo alla funzione \inline{normalize} nella sua
interezza, si osservi come esso prenda in ingresso l'albero sintattico della
formula e la variabile da eliminare ma ritorni effettivamente \inline{void},
ovvero si osservi come modifichi l'albero senza costruirne uno nuovo. Si faccia
anche caso a come tale funzione sia fortemente vincolata alla rigida struttura
sintattica che è stata supposta. Tale funzione oltre a normalizzare la formula
(tutti i coefficienti della variabile da eliminare diventano $1$) agginuge anche
un opportuno predicato di divisibilità come specificato nell'algoritmo.

\subsubsection{Funzione \inline{normalize}} \srcf{void normalize}

La funzione \inline{minInf}, come suggerisce il nome, riceve in ingresso la
formula normalizzta $\varphi'$ e restituisce $\varphi'_{- \infty}$. A differenza
della funzione precedente essa restituisce effettivamente il nuovo albero.

\subsubsection{Funzione \inline{minInf}} \srcf{t_syntaxTree* minInf}

Prima di passare alla discussione della funzione \inline{newFormula}, che
effetivamente restituisce la formula equivalente senza variabile, è bene
discutere di alcune altre funzioni a cui essa si appoggia, cioè \inline{calcm} e
\inline{boundaryPoints}.  La funzione \inline{int calcm(t_syntaxTree* tree,
char* var)} prende in ingresso l'albero della formula $\varphi'$ e la variabile
da eliminare e restituisce il minimo comune multiplo di tutti i coefficienti
della $x$ che appaiono nella formula, cioè calcola $m$ dell'equivalenza di cui
si è giò discusso.

$$ \exists \, x \, . \, \varphi'[x] \longleftrightarrow \bigvee_{j=1}^m \Big(
\varphi'_{- \infty}[j] \lor \bigvee_{b \in B}(\varphi'[b+j]) \Big)$$

\subsubsection{Funzione \inline{calcm}} \srcf{int calcm}

La funzione \inline{t_syntaxTree* boundaryPoints(t_syntaxTree* tree, char* var)}
riceve ancora in ingresso l'albero sintattico della formula $\varphi'_{-
\infty}$ e restituisce il $B$-set $B$ della formula. Per semplicità di
rappresentazione si è scelto di usare ancora come tipo per l'output sempre
\inline{t_syntaxTree}, dove però l'albero avrà come \inline{.nodeName} la
stringa arbitraria \inline{"bPoints"}, tale scelta non ha nessun impatto e
facilita semplicemente il debugging.

\subsubsection{Funzione \inline{boundaryPoints}} \srcf{t_syntaxTree*
boundaryPoints}

Si discuta ora la funzione che restituisce la formula equivalente che poi
\inline{cooperToStr} ritorna, tale funzione è \inline{t_syntaxTree*
newFormula(t_syntaxTree* tree, t_syntaxTree* minf, char* var)}, essa non è altro
che l'applicazione dell'equivalenza già esposta più volte. Prende in ingresso le
forumule $\varphi'$ e $\varphi'_{-\infty}$ e la variabile da eliminare, è al suo
interno che vengono effettuate le chiamate a \inline{boundaryPoints} e
\inline{calcm}.

\subsubsection{Funzione \inline{newFormula}} \srcf{t_syntaxTree* newFormula}

La funzione \inline{newFormula} non fa altro che invocare \inline{calcm} e
\inline{boundaryPoints} e generare l'albero della nuova formula equivalente,
albero che poi ritorna. Eliminate le varie questioni di gestione della memoria
quello che rimane è semplicemente un ciclo \inline{for}. La funzione in realtà
fa anche uso di un'ulteriore funzione di valutazione, ovvero una funzione che
prende ingresso un albero, una variabile e un valore e va a sostituire il valore
alla variabile.

Trattasi ovviamente della funzione \inline{void eval(t_syntaxTree* tree, char*
var, t_syntaxTree* val)}, si osservi anche qui come tale funzione
potrebbe essere resa più sofisticata aggiungendo una effettiva valutazione delle
operazioni aritmetiche o logiche, ma come prima anche questo avrebbe aggiunto
una ulteriore complessità al progetto, pertanto si è scelto di non proseguire in
questa strada.

\subsubsection{Funzione \inline{eval}} \srcf{void eval}

\newpage
\section{Utilizzo}

In questa sezione verranno forniti alcuni semplici esempi di utilizzo,
innanzitutto si sottolinea come l'implementazione dell'algoritmo termini con la
funzione \inline{cooperToStr}, tutto quello che sta per essere esposto è al solo
scopo di fornire una interfaccia che permetta di verificare il corretto
funzionamento dell'algoritmo.

\subsection{Programmi di esempio}
Sono forniti assieme alla presente due programmi di esempio, il primo è
\inline{test.c}

\inputminted[linenos, mathescape=true]{C}{../test.c}

Il secondo programma di esempio è \inline{test2.c}

\inputminted[linenos, mathescape=true]{C}{../test2.c}

Come si può notare tale programma si appoggia alla funzione \inline{cooperToArray},
gemella di \inline{cooper}.

\srcf{char** cooperToArray}

\subsection{Il Makefile} \inputminted[linenos]{makefile}{../makefile}
Si consideri ora il seguente \inline{makefile}:
\'E semplice immaginare cosa facciano le regole \inline{run}, \inline{run2}, \inline{valgrind},
\inline{debug} e \inline{clean}. Ci si soffermi ora su \inline{eval} e
\inline{eq}. La prima esegue semplicemente \inline{test} con la formula in
ingresso specificata nel \inline{makefile} e cerca di valutare la formula
equivalente generata tramite il seguente script in Guile Scheme\autocite{guile}.

\subsection{Valutazione ed equivalenza}
\inputminted[linenos]{scheme}{../eval.scm}

Tale script valuta semplicemente la formula equivalente, è stato scelto un
linguaggio della famiglia Lisp in quanto condivide la sintassi con
SMT-LIB e ciò rende la valutazione della formula una semplice chiamata alla
funzione \inline{eval-string}.

Si ricorda come ovviamente tale procedura non è un verifica della
soddisfacibilità, cioè qualora fossero ancora presenti variabili nella formula
equivalente allora tale script produrrebbe un errore. Per una verifica della
soddsfacibilità si usi invece la regola \inline{eq} del \inline{makefile}.
Tale regola esegue il seguente script Python\autocite{python}.

\inputminted[linenos]{python}{../eq.py}

Tale script genera un opportuno sorgente per
z3\autocite{yices} e successivamente lo esegue (poi lo elimina), per esempio eseguendo

\begin{minted}{bash}
  make eq formula="(and (> (+ (* 1 x)) 5) (> (+ (* -1 x) (* 1 y)) 0))"
          variables="x y" guess="(> y 6)"
\end{minted}

viene generato, eseguito con z3 e infine eliminato il seguente programma:

\begin{minted}{scheme}
  (declare-const y Int)
  (assert (not (= (or false (and (> (+ (+ 6)) 5) (> (+ (- (+ 6)) (* 1 y)) 0)
                      (= (mod (+ 6) 1) 0))) (> y 6))))
  (check-sat)
\end{minted}

A questo punto lo script Python valuta ciò che z3 restituisce e stampa se le formule
sono equivalenti o meno.

\subsection{Esempi}
Vengono mostrati ora alcuni esempi di utilizzo della libreriatramite il comando
\inline{make eq}.
\subsubsection{Esempio 1}
Si voglia eliminare la variabile $x$ dalla seguente formula:

$$ x > 5 \land y < x $$
\'E immediato osservare che tale formula è equivalente a $y > 6$, pertanto
eseguiamo il comando
\begin{minted}{bash}
  make eq formula="(and (> (+ (* 1 x)) 5) (> (+ (* -1 x) (* 1 y)) 0))"
          variables="x y" guess="(> y 6)"
\end{minted}
Ovvero verifichiamo se quanto produce l'algoritmo di Cooper sia equivalente o
meno a $y > 6$ (passato a \inline{make eq} come parametro \inline{guess}).
Si ricorda che i nomi delle variabili contenute in \inline{formula} vanno
passate a \inline{make eq} come parametro \inline{variables} e che la prima
di esse \'e quella che viene eliminata.
Eseguendo questo comando otteniamo come voluto "Sono equivalenti".
Si ribadisce come la forma di \inline{formula} che si aspetta il programma debba
rispettare quanto detto nei capitoli precedenti, ovvero:

\begin{itemize}
\item la radice della formula deve essere un \inline{and}
\item i figli della radice possono essere esclusivamente \inline{>}, \inline{=} o \inline{div}
\item ognuno di questi deve avere esattamente 2 figli: il primo deve essere un \inline{+} e
  il secondo un numero (eventualmente con segno negativo)
\item i figli di \inline{+} possono essere solamente \inline{*} e ognuno di questi deve avere
  esattamente due figli: il primo un numero (eventualmente con segno negativo) e il secondo una
  variabile (lunga massimo 16 caratteri).
\item \'e possibile avere anche figli di \inline{+} che siano \inline{*} con
  entrambi i figli costanti, in tal caso per\'o il primo figlio deve essere
  necessariamente \inline{1} o \inline{-1}. Questo si rivela fondamentale per inserire
  costanti nelle formule con \inline{div}
\end{itemize}

\subsubsection{Esempio 2}
\'E anche possibile verificare direttamente la verit\'a delle formule
confrontando se esse sono equivalenti a \inline{true} e \inline{false}.
Si voglia controllare se la seguente formula \'e vera:

$$ x = 2k \land x \equiv_2 1 $$
Tale formula, palesemente falsa, pu\'o essere verificata con il comando

\begin{minted}{bash}
  make eq formula="(and (= (+ (* 1 x) (* -2 k)) 0) (div (+ (* 1 1) (* 1 x)) 2))"
          variables="x k" guess="true"
\end{minted}

Ossia si controlla se la formula \'e equivalente a \inline{true}, che essendo
falso, fa si che venga stampato che le formule non sono equivalenti.

\subsubsection{Esempio 3}
Analogamente al precedente esempio si verifica che invece la seguente formula
\'e vera

$$ x = 2k + 1 \land x \equiv_2 1 $$
Il comando
\begin{minted}{bash}
  make eq formula="(and (= (+ (* 1 x) (* -2 k)) 1) (div (+ (* 1 1) (* 1 x)) 2))"
          2variables="x k" guess="true"
\end{minted}
restituisce "Non sono equivalenti".
Si osservi come in questi ultimi due esempi si sarebbe potuto scambiare l'ordine delle
variabili $x$ e $k$ in \inline{variables}, ovvero eliminare $k$ invece di $x$.

\newpage
\tableofcontents

\newpage \printbibliography


\end{document}
